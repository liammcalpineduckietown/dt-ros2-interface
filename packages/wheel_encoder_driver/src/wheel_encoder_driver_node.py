#!/usr/bin/env python3

import asyncio
from math import pi

import rospy
import tf
from duckietown_msgs.msg import WheelEncoderStamped
from geometry_msgs.msg import TransformStamped, Transform, Quaternion
from tf2_ros import TransformBroadcaster

from dt_robot_utils import get_robot_name
from dtps import context
from dtps_http import RawData
from duckietown.dtros import DTROS, TopicType, NodeType
from duckietown_messages.standard.integer import Integer
from duckietown_messages.utils.exceptions import DataDecodingError

RESOLUTION: int = 135


class WheelEncoderNode(DTROS):
    """
    Node handling a single wheel encoder.

    This node is responsible for reading data off of a single wheel encoders.
    Robots with N wheels will need to spin N instances of this node.

    Publishers:
       ~data (:obj:`WheelEncoderStamped`): Publishes the cumulative number of ticks
                                            generated by the encoder.

    """

    def __init__(self):
        super(WheelEncoderNode, self).__init__(node_name="wheel_encoder", node_type=NodeType.DRIVER)
        self._robot_name = get_robot_name()
        # get parameters
        self._wheel: str = rospy.get_param("~wheel")
        # publishers
        self._pub = rospy.Publisher(
            "~tick", WheelEncoderStamped, queue_size=1, dt_topic_type=TopicType.DRIVER
        )
        # tf broadcaster for wheel frame
        self._tf_broadcaster = TransformBroadcaster()
        # user hardware test
        # self._hardware_test = HardwareTestWheelEncoder(wheel_side=self._wheel)
        # ---
        self.loginfo("Initialized.")

    async def publish(self, data: RawData):
        # TODO: only publish if somebody is listening
        # decode data
        try:
            ticks: Integer = Integer.from_rawdata(data)
        except DataDecodingError as e:
            self.logerr(f"Failed to decode an incoming message: {e.message}")
            return
        # create encoder ticks message
        ticks_msg: WheelEncoderStamped = WheelEncoderStamped(
            header=rospy.Header(
                # TODO: reuse the timestamp from the incoming message
                stamp=rospy.Time.now(),
                frame_id=f"{self._robot_name}/{self._wheel}_wheel_axis",
            ),
            data=ticks.data,
            # TODO: get resolution from the sensor itself
            resolution=RESOLUTION,
            type=WheelEncoderStamped.ENCODER_TYPE_INCREMENTAL,
        )
        # publish messages
        self._pub.publish(ticks_msg)
        # publish TF
        angle = (float(ticks.data) / float(RESOLUTION)) * 2 * pi
        quat = tf.transformations.quaternion_from_euler(0, angle, 0)
        self._tf_broadcaster.sendTransform(
            TransformStamped(
                header=rospy.Header(
                    # TODO: reuse the timestamp from the incoming message
                    stamp=rospy.Time.now(),
                    frame_id=ticks.header.frame,
                ),
                child_frame_id=f"{self._robot_name}/{self._wheel}_wheel",
                transform=Transform(rotation=Quaternion(x=quat[0], y=quat[1], z=quat[2], w=quat[3])),
            )
        )

    async def worker(self):
        # create switchboard context
        switchboard = (await context("switchboard")).navigate(self._robot_name)
        # wheel encoder queue
        encoder = await (switchboard / "sensor" / "wheel-encoder" / self._wheel).until_ready()
        # subscribe
        await encoder.subscribe(self.publish)
        # ---
        await self.join()

    async def join(self):
        while not self.is_shutdown:
            await asyncio.sleep(1)

    def spin(self):
        try:
            asyncio.run(self.worker())
        except RuntimeError:
            if not self.is_shutdown:
                self.logerr("An error occurred while running the event loop")
                raise

    def on_shutdown(self):
        loop: asyncio.AbstractEventLoop = asyncio.get_event_loop()
        if loop is not None:
            self.loginfo("Shutting down the event loop")
            loop.stop()


if __name__ == "__main__":
    # initialize the node
    node = WheelEncoderNode()
    # keep the node alive
    node.spin()
